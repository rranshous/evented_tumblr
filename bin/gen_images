#!/usr/bin/env ruby
#
require 'fileutils'
require 'yaml'
require 'json'

# GOAL
# build a docker container for each foreman entry
# in the directory tree
# we'll give each container a port, so that we don't have
# to tell the workers from the webapps for now

build_target = ARGV.shift
if build_target.nil? || build_target.chomp == ""
  build_target = false
end
image_prefix = ARGV.shift

puts "build target: #{build_target}"
puts "image_prefix: #{image_prefix}"

# go through each of the proc files
Dir['**/Procfile'].each do |proc_path|
  app_dir = File.dirname proc_path
  app_name = app_dir.split('/').join('_')
  next if build_target && build_target != app_name
  puts "application: #{app_name} :: #{app_dir}"
  # copy the directory to tmp, so that we can add things w/o changing
  # the source direcotry
  build_id = rand(10000)
  build_dir = "/tmp/#{build_id}"
  puts "build dir: #{build_dir}"
  FileUtils.cp_r app_dir, build_dir
  # go through each entry in the procfile
  YAML.load_file(proc_path).each do |(command_name, command)|
    # create a container for each entry
    puts "Procfile command: #{command_name}"
    dockerfile_path = File.join(build_dir, 'Dockerfile')
    File.open(dockerfile_path, 'w') do |fh|
      fh.write """
        FROM tutum/buildstep
        ENV PORT 5000
        CMD #{command.split(' ').to_json}
      """
    end
    # exec a build in the directory, saving image
    # usin the applications name and the command name
    # as the image name
    image_name = "#{image_prefix}#{app_name}-#{command_name}"
    # if the image already exists, update it in place
    if `docker images | cut -d' ' -f1`.split("\n").include?(image_name)
      puts "updating existing image place"
      # run a container from the existing image, upate app in place, re-bundle
      cmd = "cd #{build_dir} && tar -c . | docker run -i -a stdin #{image_name} /bin/bash -c 'rm -rf /app && mkdir -p /app && tar -xC /app && bundle install'"
      id = `#{cmd}`.chomp
      print "Waiting: "
      unless system("docker wait #{id}")
        raise "failed to wait for container: #{id}"
      end
      # replace the existing image w/ a commit of new container
      cmd = "docker commit #{id} #{image_name}"
      unless system(cmd)
        raise "failed to commit: #{id}"
      end
    else
      cmd = "cd #{build_dir} && docker build -t #{image_name} ."
      puts "building using: #{cmd}"
      unless system(cmd)
        puts "FAIL, retrying indef"
        redo
        #raise "COMMAND FAIL: #{cmd}"
      end
    end
    if ARGV.include? 'push'
      cmd = "docker push #{image_name}"
      puts "pushing using: #{cmd}"
      unless system(cmd)
        puts "FAIL, retrying indef"
        redo
      end
    end
  end
  # clean up the tmp dir
  #FileUtils.rm_rf build_dir
end
